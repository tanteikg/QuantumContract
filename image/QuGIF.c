/******************************************
 * Name: QuGIF.c
 *
 * Author: Tan Teik Guan
 *
 * All rights reserved.
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by Tan Teik Guan. The name of
 * Tan Teik Guan may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Copyright pQCee 2023. All rights reserved
 *
 * “Commons Clause” License Condition v1.0
 *
 * The Software is provided to you by the Licensor under the License, as defined below, subject to the following
 * condition.
 *
 * Without limiting other conditions in the License, the grant of rights under the License will not include, and
 * the License does not grant to you, the right to Sell the Software.
 *
 * For purposes of the foregoing, “Sell” means practicing any or all of the rights granted to you under the License
 * to provide to third parties, for a fee or other consideration (including without limitation fees for hosting or
 * consulting/ support services related to the Software), a product or service whose value derives, entirely or
 * substantially, from the functionality of the Software. Any license notice or attribution required by the License
 * must also include this Commons Clause License Condition notice.
 *
 * Software: QuGIF 
 *
 * License: MIT 1.0
 *
 * Licensor: pQCee Pte Ltd
 *
 *****************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "gifenc.h"


#define GIFBLOB_SIZE 2000000

#ifdef WASM
#include <emscripten.h>
#endif

static char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
				'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
				'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
 				'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
				'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
				'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
				'w', 'x', 'y', 'z', '0', '1', '2', '3',
				'4', '5', '6', '7', '8', '9', '+', '/'};
static char decoding_table[256];
static int mod_table[] = {0, 2, 1};
static int decoding_table_init =0;

char *base64_encode(const unsigned char *data, size_t input_length, char * encoded_data, size_t *output_length)
{
	*output_length = 4 * ((input_length + 2) / 3);
//      char *encoded_data = malloc(*output_length);
	if (encoded_data == NULL) return NULL;
	for (int i = 0, j = 0; i < input_length;)
	{
		uint32_t octet_a = i < input_length ? (unsigned char)data[i++] : 0;
		uint32_t octet_b = i < input_length ? (unsigned char)data[i++] : 0;
		uint32_t octet_c = i < input_length ? (unsigned char)data[i++] : 0;
		uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
		encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
		encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
		encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
		encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
	}
	for (int i = 0; i < mod_table[input_length % 3]; i++)
		encoded_data[*output_length - 1 - i] = '=';

	return encoded_data;
}

unsigned char *base64_decode(const char *data, size_t input_length, unsigned char * decoded_data, size_t *output_length)
{
	if (!decoding_table_init)
	{
		memset(decoding_table,0,256);
		for (int i = 0; i < 64; i++)
			decoding_table[(unsigned char) encoding_table[i]] = i;
		decoding_table_init = 1;
	}

	if (input_length % 4 != 0) return NULL;

	*output_length = input_length / 4 * 3;
	if (data[input_length - 1] == '=') (*output_length)--;
	if (data[input_length - 2] == '=') (*output_length)--;

//      unsigned char *decoded_data = malloc(*output_length);
	if (decoded_data == NULL) return NULL;

	for (int i = 0, j = 0; i < input_length;)
	{
		uint32_t sextet_a = data[i] == '=' ? 0 & i++ : decoding_table[data[i++]];
		uint32_t sextet_b = data[i] == '=' ? 0 & i++ : decoding_table[data[i++]];
		uint32_t sextet_c = data[i] == '=' ? 0 & i++ : decoding_table[data[i++]];
		uint32_t sextet_d = data[i] == '=' ? 0 & i++ : decoding_table[data[i++]];
		uint32_t triple = (sextet_a << 3 * 6) + (sextet_b << 2 * 6) + (sextet_c << 1 * 6) + (sextet_d << 0 * 6);

		if (j < *output_length) decoded_data[j++] = (triple >> 2 * 8) & 0xFF;
		if (j < *output_length) decoded_data[j++] = (triple >> 1 * 8) & 0xFF;
		if (j < *output_length) decoded_data[j++] = (triple >> 0 * 8) & 0xFF;
	}

	return decoded_data;
}

#ifdef WASM
EMSCRIPTEN_KEEPALIVE
#endif
char * create_GIF(int numQubits, unsigned char * colourBlock)
{
	unsigned char * Blob;
	int Blobsize;
	char * ret = NULL;
	size_t retlen;
	uint8_t palette1[] = {
		0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF};
	uint8_t palette2[] = {
		0x00, 0x00, 0x00, 0xFF, 0xF0, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF};
	uint8_t palette3[] = {
		0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00,
		0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
	uint8_t palette4[] = {
		0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x03, 0xF0, 0x00, 0xFF, 0xF0, 0x00,
		0x00, 0x0F, 0xC0, 0xFC, 0x0F, 0xC0, 0x03, 0xFF, 0xC0, 0xFF, 0xFF, 0xC0,
		0x00, 0x00, 0x3F, 0xFC, 0x00, 0x3F, 0x03, 0xF0, 0x3F, 0xFF, 0xF0, 0x3F,
		0x00, 0x0F, 0xFF, 0xFC, 0x0F, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
	uint8_t palette6[] = {
		0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0x00, 0x00, 0xFF, 0x00, 0x00, 
		0x00, 0xF0, 0x00, 0xF0, 0xF0, 0x00, 0x0F, 0xF0, 0x00, 0xFF, 0xF0, 0x00, 
		0x00, 0x0F, 0x00, 0xF0, 0x0F, 0x00, 0x0F, 0x0F, 0x00, 0xFF, 0x0F, 0x00, 
		0x00, 0xFF, 0x00, 0xF0, 0xFF, 0x00, 0x0F, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 
		0x00, 0x00, 0xF0, 0xF0, 0x00, 0xF0, 0x0F, 0x00, 0xF0, 0xFF, 0x00, 0xF0,
		0x00, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x0F, 0xF0, 0xF0, 0xFF, 0xF0, 0xF0, 
		0x00, 0x0F, 0xF0, 0xF0, 0x0F, 0xF0, 0x0F, 0x0F, 0xF0, 0xFF, 0x0F, 0xF0, 
		0x00, 0xFF, 0xF0, 0xF0, 0xFF, 0xF0, 0x0F, 0xFF, 0xF0, 0xFF, 0xFF, 0xF0, 
		0x00, 0x00, 0x0F, 0xF0, 0x00, 0x0F, 0x0F, 0x00, 0x0F, 0xFF, 0x00, 0x0F, 
		0x00, 0xF0, 0x0F, 0xF0, 0xF0, 0x0F, 0x0F, 0xF0, 0x0F, 0xFF, 0xF0, 0x0F,
		0x00, 0x0F, 0x0F, 0xF0, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0xFF, 0x0F, 0x0F, 
		0x00, 0xFF, 0x0F, 0xF0, 0xFF, 0x0F, 0x0F, 0xFF, 0x0F, 0xFF, 0xFF, 0x0F, 
		0x00, 0x00, 0xFF, 0xF0, 0x00, 0xFF, 0x0F, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 
		0x00, 0xF0, 0xFF, 0xF0, 0xF0, 0xFF, 0x0F, 0xF0, 0xFF, 0xFF, 0xF0, 0xFF, 
		0x00, 0x0F, 0xFF, 0xF0, 0x0F, 0xFF, 0x0F, 0x0F, 0xFF, 0xFF, 0x0F, 0xFF,
		0x00, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}; 
	uint8_t palette8[] = {
		0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x1C, 0x00, 0x00, 0xFC, 0x00, 0x00,
		0x03, 0x80, 0x00, 0xE3, 0x80, 0x00, 0x1F, 0x80, 0x00, 0xFF, 0x80, 0x00,
		0x00, 0x70, 0x00, 0xE0, 0x70, 0x00, 0x1C, 0x70, 0x00, 0xFC, 0x70, 0x00,
		0x03, 0xF0, 0x00, 0xE3, 0xF0, 0x00, 0x1F, 0xF0, 0x00, 0xFF, 0xF0, 0x00,
		0x00, 0x0E, 0x00, 0xE0, 0x0E, 0x00, 0x1C, 0x0E, 0x00, 0xFC, 0x0E, 0x00,
		0x03, 0x8E, 0x00, 0xE3, 0x8E, 0x00, 0x1F, 0x8E, 0x00, 0xFF, 0x8E, 0x00,
		0x00, 0x7E, 0x00, 0xE0, 0x7E, 0x00, 0x1C, 0x7E, 0x00, 0xFC, 0x7E, 0x00,
		0x03, 0xFE, 0x00, 0xE3, 0xFE, 0x00, 0x1F, 0xFE, 0x00, 0xFF, 0xFE, 0x00,
		0x00, 0x01, 0xC0, 0xE0, 0x01, 0xC0, 0x1C, 0x01, 0xC0, 0xFC, 0x01, 0xC0,
		0x03, 0x81, 0xC0, 0xE3, 0x81, 0xC0, 0x1F, 0x81, 0xC0, 0xFF, 0x81, 0xC0,
		0x00, 0x71, 0xC0, 0xE0, 0x71, 0xC0, 0x1C, 0x71, 0xC0, 0xFC, 0x71, 0xC0,
		0x03, 0xF1, 0xC0, 0xE3, 0xF1, 0xC0, 0x1F, 0xF1, 0xC0, 0xFF, 0xF1, 0xC0,
		0x00, 0x0F, 0xC0, 0xE0, 0x0F, 0xC0, 0x1C, 0x0F, 0xC0, 0xFC, 0x0F, 0xC0,
		0x03, 0x8F, 0xC0, 0xE3, 0x8F, 0xC0, 0x1F, 0x8F, 0xC0, 0xFF, 0x8F, 0xC0,
		0x00, 0x7F, 0xC0, 0xE0, 0x7F, 0xC0, 0x1C, 0x7F, 0xC0, 0xFC, 0x7F, 0xC0,
		0x03, 0xFF, 0xC0, 0xE3, 0xFF, 0xC0, 0x1F, 0xFF, 0xC0, 0xFF, 0xFF, 0xC0,
		0x00, 0x00, 0x38, 0xE0, 0x00, 0x38, 0x1C, 0x00, 0x38, 0xFC, 0x00, 0x38,
		0x03, 0x80, 0x38, 0xE3, 0x80, 0x38, 0x1F, 0x80, 0x38, 0xFF, 0x80, 0x38,
		0x00, 0x70, 0x38, 0xE0, 0x70, 0x38, 0x1C, 0x70, 0x38, 0xFC, 0x70, 0x38,
		0x03, 0xF0, 0x38, 0xE3, 0xF0, 0x38, 0x1F, 0xF0, 0x38, 0xFF, 0xF0, 0x38,
		0x00, 0x0E, 0x38, 0xE0, 0x0E, 0x38, 0x1C, 0x0E, 0x38, 0xFC, 0x0E, 0x38,
		0x03, 0x8E, 0x38, 0xE3, 0x8E, 0x38, 0x1F, 0x8E, 0x38, 0xFF, 0x8E, 0x38,
		0x00, 0x7E, 0x38, 0xE0, 0x7E, 0x38, 0x1C, 0x7E, 0x38, 0xFC, 0x7E, 0x38,
		0x03, 0xFE, 0x38, 0xE3, 0xFE, 0x38, 0x1F, 0xFE, 0x38, 0xFF, 0xFE, 0x38,
		0x00, 0x01, 0xF8, 0xE0, 0x01, 0xF8, 0x1C, 0x01, 0xF8, 0xFC, 0x01, 0xF8,
		0x03, 0x81, 0xF8, 0xE3, 0x81, 0xF8, 0x1F, 0x81, 0xF8, 0xFF, 0x81, 0xF8,
		0x00, 0x71, 0xF8, 0xE0, 0x71, 0xF8, 0x1C, 0x71, 0xF8, 0xFC, 0x71, 0xF8,
		0x03, 0xF1, 0xF8, 0xE3, 0xF1, 0xF8, 0x1F, 0xF1, 0xF8, 0xFF, 0xF1, 0xF8,
		0x00, 0x0F, 0xF8, 0xE0, 0x0F, 0xF8, 0x1C, 0x0F, 0xF8, 0xFC, 0x0F, 0xF8,
		0x03, 0x8F, 0xF8, 0xE3, 0x8F, 0xF8, 0x1F, 0x8F, 0xF8, 0xFF, 0x8F, 0xF8,
		0x00, 0x7F, 0xF8, 0xE0, 0x7F, 0xF8, 0x1C, 0x7F, 0xF8, 0xFC, 0x7F, 0xF8,
		0x03, 0xFF, 0xF8, 0xE3, 0xFF, 0xF8, 0x1F, 0xFF, 0xF8, 0xFF, 0xFF, 0xF8,
		0x00, 0x00, 0x07, 0xE0, 0x00, 0x07, 0x1C, 0x00, 0x07, 0xFC, 0x00, 0x07,
		0x03, 0x80, 0x07, 0xE3, 0x80, 0x07, 0x1F, 0x80, 0x07, 0xFF, 0x80, 0x07,
		0x00, 0x70, 0x07, 0xE0, 0x70, 0x07, 0x1C, 0x70, 0x07, 0xFC, 0x70, 0x07,
		0x03, 0xF0, 0x07, 0xE3, 0xF0, 0x07, 0x1F, 0xF0, 0x07, 0xFF, 0xF0, 0x07,
		0x00, 0x0E, 0x07, 0xE0, 0x0E, 0x07, 0x1C, 0x0E, 0x07, 0xFC, 0x0E, 0x07,
		0x03, 0x8E, 0x07, 0xE3, 0x8E, 0x07, 0x1F, 0x8E, 0x07, 0xFF, 0x8E, 0x07,
		0x00, 0x7E, 0x07, 0xE0, 0x7E, 0x07, 0x1C, 0x7E, 0x07, 0xFC, 0x7E, 0x07,
		0x03, 0xFE, 0x07, 0xE3, 0xFE, 0x07, 0x1F, 0xFE, 0x07, 0xFF, 0xFE, 0x07,
		0x00, 0x01, 0xC7, 0xE0, 0x01, 0xC7, 0x1C, 0x01, 0xC7, 0xFC, 0x01, 0xC7,
		0x03, 0x81, 0xC7, 0xE3, 0x81, 0xC7, 0x1F, 0x81, 0xC7, 0xFF, 0x81, 0xC7,
		0x00, 0x71, 0xC7, 0xE0, 0x71, 0xC7, 0x1C, 0x71, 0xC7, 0xFC, 0x71, 0xC7,
		0x03, 0xF1, 0xC7, 0xE3, 0xF1, 0xC7, 0x1F, 0xF1, 0xC7, 0xFF, 0xF1, 0xC7,
		0x00, 0x0F, 0xC7, 0xE0, 0x0F, 0xC7, 0x1C, 0x0F, 0xC7, 0xFC, 0x0F, 0xC7,
		0x03, 0x8F, 0xC7, 0xE3, 0x8F, 0xC7, 0x1F, 0x8F, 0xC7, 0xFF, 0x8F, 0xC7,
		0x00, 0x7F, 0xC7, 0xE0, 0x7F, 0xC7, 0x1C, 0x7F, 0xC7, 0xFC, 0x7F, 0xC7,
		0x03, 0xFF, 0xC7, 0xE3, 0xFF, 0xC7, 0x1F, 0xFF, 0xC7, 0xFF, 0xFF, 0xC7,
		0x00, 0x00, 0x3F, 0xE0, 0x00, 0x3F, 0x1C, 0x00, 0x3F, 0xFC, 0x00, 0x3F,
		0x03, 0x80, 0x3F, 0xE3, 0x80, 0x3F, 0x1F, 0x80, 0x3F, 0xFF, 0x80, 0x3F,
		0x00, 0x70, 0x3F, 0xE0, 0x70, 0x3F, 0x1C, 0x70, 0x3F, 0xFC, 0x70, 0x3F,
		0x03, 0xF0, 0x3F, 0xE3, 0xF0, 0x3F, 0x1F, 0xF0, 0x3F, 0xFF, 0xF0, 0x3F,
		0x00, 0x0E, 0x3F, 0xE0, 0x0E, 0x3F, 0x1C, 0x0E, 0x3F, 0xFC, 0x0E, 0x3F,
		0x03, 0x8E, 0x3F, 0xE3, 0x8E, 0x3F, 0x1F, 0x8E, 0x3F, 0xFF, 0x8E, 0x3F,
		0x00, 0x7E, 0x3F, 0xE0, 0x7E, 0x3F, 0x1C, 0x7E, 0x3F, 0xFC, 0x7E, 0x3F,
		0x03, 0xFE, 0x3F, 0xE3, 0xFE, 0x3F, 0x1F, 0xFE, 0x3F, 0xFF, 0xFE, 0x3F,
		0x00, 0x01, 0xFF, 0xE0, 0x01, 0xFF, 0x1C, 0x01, 0xFF, 0xFC, 0x01, 0xFF,
		0x03, 0x81, 0xFF, 0xE3, 0x81, 0xFF, 0x1F, 0x81, 0xFF, 0xFF, 0x81, 0xFF,
		0x00, 0x71, 0xFF, 0xE0, 0x71, 0xFF, 0x1C, 0x71, 0xFF, 0xFC, 0x71, 0xFF,
		0x03, 0xF1, 0xFF, 0xE3, 0xF1, 0xFF, 0x1F, 0xF1, 0xFF, 0xFF, 0xF1, 0xFF,
		0x00, 0x0F, 0xFF, 0xE0, 0x0F, 0xFF, 0x1C, 0x0F, 0xFF, 0xFC, 0x0F, 0xFF,
		0x03, 0x8F, 0xFF, 0xE3, 0x8F, 0xFF, 0x1F, 0x8F, 0xFF, 0xFF, 0x8F, 0xFF,
		0x00, 0x7F, 0xFF, 0xE0, 0x7F, 0xFF, 0x1C, 0x7F, 0xFF, 0xFC, 0x7F, 0xFF,
		0x03, 0xFF, 0xFF, 0xE3, 0xFF, 0xFF, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

	int w = 256, h = 256;
	int k;
	unsigned char * finalColour;
//	unsigned int seed = strlen(argv[2]) + (256 * numQubits);

	Blob = malloc(GIFBLOB_SIZE);
	memset(Blob,0,GIFBLOB_SIZE);
	finalColour = malloc(w*h);
	
	uint8_t * palette = NULL;	
	if (numQubits == 1)
		palette = palette1;
	else if (numQubits == 2)
		palette = palette2;
	else if (numQubits == 3)
		palette = palette3;
	else if (numQubits == 4)
		palette = palette4;
	else if (numQubits == 6)
		palette = palette6;
	else if (numQubits == 8)
		palette = palette8;
	else
	{
		numQubits = 8;
		palette = palette8;
	}

	ge_GIF *gif = ge_new_gif(Blob, w, h, palette, numQubits, -1, 0);

//	srand(seed);

	for (int i = 0; i < w*h; i++)
		gif->frame[i] = 0; // starting block

	for (int i = 0; i < numQubits; i++)
		for (int k = 0; k < (256/numQubits); k++)
			for (int j = 0; j < (256/numQubits); j++)
			{
				for (int k1=0;k1<numQubits;k1++)
				{
					finalColour[i*256*(256/numQubits) + k*256 + j*numQubits + k1] = colourBlock[i*(256/numQubits)+j];
        			}
			}

// for printing diagonals
	for (int i=0; i < 256; i++)
	{
		k = i;
		for (int j=0; j<=i;j++)
		{
		//	gif->frame[k*256+j] = colourblock[rand()%256];
			gif->frame[k*256+j] = finalColour[k*256+j];
			k--;
		}
		if ((i % 16) == 0)
		{
			void * tmp;
			ge_add_frame(gif,1);
			tmp = gif->back;
			gif->back = gif->frame;
			gif->frame=tmp;
			memset(gif->frame,0,h*w);
		}
	}
		
	for (int j=1; j < 256; j++)
	{
		k=j;
		for (int i=255;i>=j;i--)
		{
//			gif->frame[i*256+k] = colourblock[rand() % 256];
			gif->frame[i*256+k] = finalColour[i*256+k];
			k++;
		}
		if ((j % 16) == 0)
		{
			void * tmp;
			ge_add_frame(gif,1);
			tmp = gif->back;
			gif->back = gif->frame;
			gif->frame=tmp;
			memset(gif->frame,0,h*w);
		}
	}

	for (int i = 0; i < w*h; i++)
		gif->frame[i] = finalColour[i];
	
	ge_add_frame(gif,200);

	Blobsize = ge_close_gif(gif);		
	retlen = 4 * ((Blobsize+2)/3);
	ret = malloc(retlen+1);
	memset(ret,0,retlen+1);
	base64_encode(Blob,Blobsize,ret,&retlen);
	free(finalColour);

	free(Blob);	
	return ret;
	
}

#ifdef WASM
EMSCRIPTEN_KEEPALIVE
#endif
void clearbuf(char * ret)
{
	if (ret)
		free(ret);
}

#ifndef WASM
int main(int argc, char * argv[])
{
	unsigned char Blob[GIFBLOB_SIZE];
	size_t Bloblen = sizeof(Blob);
	unsigned char colourBlock[256];

	for (int i = 0; i < 256; i++)
	{
		colourBlock[i] = i % 64;
	}
	char * ret = create_GIF(6, colourBlock);
	FILE * g = fopen("a.txt","w");
	fwrite(ret,1,strlen(ret),g);
	fclose(g);
	base64_decode(ret,strlen(ret),Blob,&Bloblen);
	FILE * f = fopen("a.gif","wb");
	fwrite(Blob,Bloblen,1,f);
	fclose(f);
	clearbuf(ret);
	
	return 0;
}
#endif

